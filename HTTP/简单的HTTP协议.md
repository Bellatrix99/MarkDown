# 简单的 HTTP 协议

![image-20210517140445198](https://i.loli.net/2021/05/17/N3PzsYiRfWcweXh.png)

> 仅从一条通信路线来说，服务器端和客户端的角色是确定的，而 HTTP 协议能够明确区分哪端是客户端，哪端是服务器端。

## 1. 请求和响应

![image-20210517140652445](https://i.loli.net/2021/05/17/El9Ju2fVaDyOkqY.png)

## 2. HTTP 是无状态（stateless）的协议

**`HTTP` 协议自身不对请求和响应之间的通信状态进行保存。**

![image-20210517141017059](https://i.loli.net/2021/05/17/F1puy5YaBOeQo6i.png)

协议本身并不会保留之前一切的请求或响应报文的信息。这是**为了更快的处理大量事务**，确保协议的可伸缩性，而特意把 `HTTP` 协议设计成如此简单的。

> 可随着 `Web` 的不断发展，因无状态而导致业务处理变得更加棘手；为了实现期望的保持状态功能，引入了 `Cookie` 技术。这样就可以管理状态了。

## 3. 请求 URI 定位资源

`HTTP` 协议使用 `URI` 定位互联网上的资源。

![image-20210517141654642](https://i.loli.net/2021/05/17/5VUQn2ZY6bpz9ql.png)

如果不是访问特定资源而是对服务器本身发起请求，可以用一个 `*` 来代替请求 `URI`。

## 4. 告知服务器意图的 HTTP 方法

### 4.1 GET: 获取资源

`GET` 方法用来请求访问已被 `URI` 识别的资源。指定的资源经服务器端解析后返回响应内容。

![image-20210517142318467](https://i.loli.net/2021/05/17/sM5OfLzW1PIXChA.png)

### 4.2 POST: 传输实体主体

`POST` 方法用来传输实体的主体。

`GET` 方法也可以传输实体的主体，但一般使用 `POST` 方法。`GET` 方法会把信息暴露在地址栏中。

`POST` 的功能与 `GET` 很相似，但 `POST` 的主要目的并不是获取响应的主体内容。

![image-20210517142641085](https://i.loli.net/2021/05/17/lyX8NtEG5oevpdH.png)

### 4.3 PUT: 传输文件

`PUT` 方法用来传输文件。要求在请求报文的主体中包含文件的内容，然后保存到请求 `URI` 指定的位置。

当配合 `Web` 应用程序的验证机制，或遵守 `REST` 标准时可能开放使用。

> REST（REpresentational State Transfer，表征状态转移）

![image-20210517142944916](https://i.loli.net/2021/05/17/PxY1Vh8GDyAl5UB.png)

### 4.4 HEAD: 获取报文首部

`HEAD` 方法和 `GET` 方法一样，只是不返回报文主体内容。用于确认 `URI` 的有效性及资源更新的日期时间等。

![image-20210517143535474](https://i.loli.net/2021/05/17/2QCcvOmRtsKunZj.png)

### 4.5 DELETE: 删除文件

**`DELETE` 方法用来删除文件，是与 `PUT` 相反的方法。**

`DELETE` 方法按请求 `URI` 删除指定的资源。

当配合 `Web` 应用程序的验证机制，或遵守 `REST` 标准时可能开放使用。

![image-20210517154158779](https://i.loli.net/2021/05/17/9UdLQnXaJzBRDCZ.png)

### 4.6 OPTIONS: 询问支持的方法

`OPTIONS` 方法用来查询针对请求 `URI` 指定的资源支持的方法。

![image-20210517154355464](https://i.loli.net/2021/05/17/QAWUbFe9nL3Sd5Z.png)

### 4.7 TRACE: 追踪路径

`TRACE` 方法是让 `Web` 服务器端将之前的请求通信环回给客户端的方法。

发送请求时，在 `Max-Forwards` 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务端则返回状态码 `200 OK` 的响应。

客户端通过 `TRACE` 方法可以查询发送出去的请求时怎么杨加工修改 / 篡改的。因为当请求想要连接到原目标服务器时可能会通过代理中转，`TRACE` 方法就是用来确认链接过程中发生的一系列操作。

`TRACE` 方法不常用，也容易引发 `XST`（Cross-Site Tracing，跨站追踪）攻击，所以很少用到。

![image-20210517155110836](https://i.loli.net/2021/05/17/2AVlOWwBJIyetd5.png)

### 4.8 CONNECT: 要求用隧道协议连接代理

`CONNECT` 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 `TCP` 通信。主要使用 `SSL`（Secure Sockets Layer，安全套接层）和 `TLS`（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。

`CONNECT` 方法的格式如下：

`CONNECT 代理服务器名 : 端口号 HTTP版本`

![image-20210517155543443](https://i.loli.net/2021/05/17/SPu8FGVJ6Y2Ih4O.png)

## 5. 使用方法下达命令

向请求 `URI` 指定的资源发送请求报文时，采用称为方法的命令。

方法的作用在于，可以指定请求的资源按期望产生某种行为。

![image-20210517155806359](https://i.loli.net/2021/05/17/RYsCxHGrS7E2Jvu.png)

| 方法      | 说明                     |
| --------- | ------------------------ |
| GET       | 获取资源                 |
| POST      | 传输实体主体             |
| PUT       | 传输文件                 |
| HEAD      | 获得报文首部             |
| DELETE    | 删除文件                 |
| OPTION    | 询问支持的方法           |
| TRACE     | 追踪路径                 |
| CONNECT   | 要求使用隧道协议连接代理 |
| ~~LINK~~ | 建立和资源之间的联系     |
| ~~UNLINK~~    | 断开连接关系             |

## 6. 持久连接节省通信量

`HTTP` 协议的初始版本，每进行一次 `HTTP` 通信就要断开一次 `TCP` 连接。

![image-20210517160405909](https://i.loli.net/2021/05/17/HNa6YzZroKC3gAW.png)

假如，使用浏览器浏览一个包含多张图片的 `HTML` 页面时，在发送请求访问 `HTML` 页面资源的同时，也会请求该 `HTML` 页面里包含的其他资源。因此，每次的请求都会造成无谓的 `TCP` 连接建立和断开，增加通信量的开销。

![image-20210517160714304](https://i.loli.net/2021/05/17/9zvmRGWhu7CNDdp.png)

### 6.1 持久连接

为了解决以上 `TCP` 连接问题，就提出了`HTTP keep-alive`（或 HTTP connection reuse）的方法。

持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 `TCP` 连接状态

![image-20210517160912939](https://i.loli.net/2021/05/17/n5A3wi629K1UuoX.png)

持久连接的好处在于减少了 `TCP` 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。

另外，减少开销省下的时间，使得 `HTTP` 请求和响应能够更早的结束，这样 `Web` 页面显示速度也响应提高。

### 6.2 管线化

持久连接使得多数请求以管线化（pipelining）方式发送成为可能。

管线化技术出现后，不用等待响应亦可直接发送下一个请求。

这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。

![image-20210517161321213](https://i.loli.net/2021/05/17/mhsxVBC17XHJAlj.png)

**管线化技术比持久连接还要快。请求数越多，时间差就越明显。**

## 7. 使用 Cookie 的状态管理

`HTTP` 时无状态协议，它不对之前发生过的请求和响应的状态进行管理。

无状态协议的优点：

- 减少服务器的 `CPU` 及内存资源的消耗。

- 也正是因为 `HTTP` 协议本身那么简单，所以才被应用在各种场景里。

![image-20210517162516873](https://i.loli.net/2021/05/17/2mEIf59pjtUD43x.png)

保留无状态协议的同时又要解决类似的矛盾问题，于是引入了 `Cookie` 技术。

`Cookie` 技术通过在请求和响应报文重写入` Cookie` 信息来控制客户端的状态。

`Cookie` 会根据从服务器端发送的响应报文内的一个叫做 `Set-Cookie` 的首部字段信息，通知客户端保存 `Cookie`。当下次客户端再往服务器发送请求时，客户端会自动在请求报文中添加 `Cookie` 值后发送出去。

服务器端发现客户端发送过来的 `Cookie` 后，会去检查究竟是从哪一个客户端发送来的请求连接，然后对比服务器上的记录，最后得到之前的状态信息。

![image-20210517162934628](https://i.loli.net/2021/05/17/TAjsKSwBfnFCeH9.png)

